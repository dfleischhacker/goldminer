package miner.ontology;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parser for association rule files generated by Borgelt's association rule miner
 */
public class AssociationRulesParser {

    public AssociationRulesParser() {
    }

    /**
     * Parses the given association rule file assuming it to be in the format generated by Borgelt's miner. Supports
     * parsing of rules with one or two antecedents.
     *
     * <ul>
     *     <li>C <- A1 (supp, conf)</li>
     *     <li>C <- A1 A2 (supp, conf)</li>
     * </ul>
     * @param rules association rule file to parse
     * @param secondAnte if true, try to parse a second antecedent
     * @return list of all parsed axioms
     * @throws IOException on errors reading the association rule file
     */
    public List<ParsedAxiom> parse(File rules, boolean secondAnte) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(rules));
        String patternRegex;
        if (secondAnte) {
            patternRegex = "^(\\d+)\\s+<-\\s+(\\d+)\\s+(\\d+)\\s+\\((\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?),\\s+(\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?)\\)$";
        }
        else {
            patternRegex = "^(\\d+)\\s+<-\\s+(\\d+)\\s+\\((\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?),\\s+(\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?)\\)$";
        }
        String line;
        Pattern pattern = Pattern.compile(patternRegex);
        List<ParsedAxiom> axioms = new ArrayList<ParsedAxiom>();
        while ((line = in.readLine()) != null) {
            Matcher matcher = pattern.matcher(line.trim());
            boolean matches = matcher.matches();
            if (!matches || matcher.groupCount() != 4) {
                continue;
            }
            int cons = Integer.parseInt(matcher.group(1));
            int ante = Integer.parseInt(matcher.group(2));

            int counter = 3;
            int ante2 = -1;
            if (secondAnte) {
                ante2 = Integer.parseInt(matcher.group(counter++));
            }
            double supp = Double.parseDouble(matcher.group(counter++));
            double conf = Double.parseDouble(matcher.group(counter));
            if (secondAnte) {
                axioms.add(new ParsedAxiom(ante, ante2, cons, supp, conf));
            }
            else {
                axioms.add(new ParsedAxiom(ante, cons, supp, conf));
            }
        }
        in.close();
        return axioms;
    }
}
