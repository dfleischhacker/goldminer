package de.uni_mannheim.informatik.dws.goldminer.ontology;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parser for association rule files generated by Borgelt's association rule miner
 */
public class AssociationRulesParser {
    /**
     * Parses the given association rule file assuming it to be in the format generated by Borgelt's miner. Supports
     * parsing of rules with one or two antecedents.
     * <p/>
     * <ul> <li>C <- A1 (supp, conf)</li> <li>C <- A1 A2 (supp, conf)</li> </ul>
     *
     * @param rules      association rule file to parse
     * @param secondAnte if true, try to parse a second antecedent
     * @return list of all parsed axioms
     * @throws java.io.IOException on errors reading the association rule file
     */
    public List<ParsedAxiom> parse(File rules, boolean secondAnte) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(rules));
        String patternRegex;
        if (secondAnte) {
            patternRegex = "^(\\d+)\\s+<-\\s+(\\d+)\\s+(\\d+)\\s+\\((\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?),\\s+(\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?)\\)$";
        } else {
            patternRegex = "^(\\d+)\\s+<-\\s+(\\d+)\\s+\\((\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?),\\s+(\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?)\\)$";
        }
        String line;
        Pattern pattern = Pattern.compile(patternRegex);
        List<ParsedAxiom> axioms = new ArrayList<ParsedAxiom>();
        while ((line = in.readLine()) != null) {
            Matcher matcher = pattern.matcher(line.trim());
            boolean matches = matcher.matches();
            if (!matches || matcher.groupCount() != 4) {
                continue;
            }
            int cons = Integer.parseInt(matcher.group(1));
            int ante = Integer.parseInt(matcher.group(2));

            int counter = 3;
            int ante2 = -1;
            if (secondAnte) {
                ante2 = Integer.parseInt(matcher.group(counter++));
            }
            double supp = Double.parseDouble(matcher.group(counter++));
            double conf = Double.parseDouble(matcher.group(counter));
            if (secondAnte) {
                axioms.add(new ParsedAxiom(ante, ante2, cons, supp, conf));
            } else {
                axioms.add(new ParsedAxiom(ante, cons, supp, conf));
            }
        }
        in.close();
        return axioms;
    }

    /**
     * Parses the given file assuming that it contains single item antecedents
     *
     * @param file rule file to parse
     * @return list of all axioms gained by parsing the given file
     * @throws java.io.IOException
     */
    public List<ParsedAxiom> parseSingleAntecendent(File file) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(file));
        String patternRegex;
        patternRegex = "^(\\d+)\\s+<-\\s+(\\d+)\\s+\\((\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?),\\s+(\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?)\\)$";
        String line;
        Pattern pattern = Pattern.compile(patternRegex);
        List<ParsedAxiom> axioms = new ArrayList<ParsedAxiom>();
        while ((line = in.readLine()) != null) {
            Matcher matcher = pattern.matcher(line.trim());
            boolean matches = matcher.matches();
            if (!matches || matcher.groupCount() != 4) {
                continue;
            }
            int cons = Integer.parseInt(matcher.group(1));
            int ante = Integer.parseInt(matcher.group(2));

            int counter = 3;
            double supp = Double.parseDouble(matcher.group(counter++));
            double conf = Double.parseDouble(matcher.group(counter));
            axioms.add(new ParsedAxiom(ante, cons, supp, conf));
        }
        in.close();
        return axioms;
    }
}
